# Classify-Character-from-Images-in-Devanagari-script
This is a Character Recognition System which I developed for Devanagari  Script. The learning model was trained on 92 thousand images (32x32 pixels) of 46 characters, digits 0 to 9 and consonants “ka” to “gya”. The optimal result, 92% accuracy, was obtained using Extremely Randomized Decision Forest Classification algorithm. 
Character Recognition is the identification of printed characters from an image, a book, a handwritten note, cheques, or letters. It is similar to using a handheld scanner to read a barcode, or reading OMR exam sheets, but it can distinguish between different alphabets.
K Nearest Neighbors Classification, Decision Forest Classification and Random Forest Classification algorithm were selected and a Grid Search was done to obtain optimum parameters and scores of these algorithms and compare their performance.
I needed the handwritten Devanagari digits, I converted the digits dataset to CSV format. It was easier and faster to feed the CSV content into the Neural network as an input. so I used pytohn code for converting .data file into .csv file .
Our Neural network will consist of 3 layers: an input, hidden and output layer. The number of these are governed by our data. Since we have 1024 pixel values for each images, there will be 1024 input nodes. Similarly, since our output needs to be one of the 10 digits (0 to 9), that means we will have 10 output nodes. Whichever node has the highest value will be the output of the network.
we have to make a simple guess for choosing the number of hidden layers. it shoul be less than input alyer. finally weight is taken -0.5 to 0.5 randomly .
finally we have two files in .csv format, test and train now we can implement our algorithms for classification  of characater in script.
We have used sigmoid function as an activation function. The combined moderated signal is passed to the sigmoid function, 1/ (1 + e-x ), which squashes the input and gives an output for the layer. The same process is repeated between hidden and output layer.
The final output of the network is compared with the expected output for  calculate the error. We can compute the error in the output layer by simply subtracting its output to the expected output. But, to check the error in the hidden layer, we have to propagate the error backwards i.e. we need to split the errors according to the weight of the contributing links. This can be obtained by multiplying the matrix of weights of hidden layer to output layer and the error of the output layer.
Once we have the error, we need to update the link weights according to the error. We use gradient descent algorithm to refine the weights so that we can minimize our cost function.
accuracy is something about to 94%. 
